clear;clc;
N = 256;
img = imread('Transmissions/cameraman.tif');
img = imresize(img,[N N]);
%   serialize the image
img_Linear = reshape(img,[1 N*N]);
%   turn the image data into bits
%   Assume 8bits per pixel value (image entry)
dataIn = reshape(int2bit(img_Linear,8),...
    [1 8*N*N]);
%   modulate data
M = 4;
k = log2(M);
K = 10;
KdB = 10*log10(K);
ebnrdB = 15;
snrdB = convertSNR(ebnrdB,"ebno","snr","BitsPerSymbol",k);
dataSym = bit2int(dataIn', k);
txSig = pskmod(dataSym,M);
bitErrorRate_sc = zeros(1,length(snrdB));
bitErrorRate_mrc = zeros(1,length(snrdB));
h1 = rice_fading(KdB,length(txSig),1)';
h2 = rice_fading(KdB,length(txSig),1)';
h3 = rice_fading(KdB,length(txSig),1)';
h4 = rice_fading(KdB,length(txSig),1)';

channelOut1 = h1.*txSig;
channelOut2 = h2.*txSig;
channelOut3 = h3.*txSig;
channelOut4 = h4.*txSig;

rxSig1 = awgn(channelOut1,snrdB,"measured");
rxSig2 = awgn(channelOut2,snrdB,"measured");
rxSig3 = awgn(channelOut3,snrdB,"measured");
rxSig4 = awgn(channelOut4,snrdB,"measured");

rxSig = [rxSig1 rxSig2 rxSig3 rxSig4];
h = [h1 h2 h3 h4];
r = selectionCombining(rxSig, h);
r2 = maximalRatioCombining(rxSig,h);
rxSym_sc = pskdemod(r,M);
rxSym_mrc = pskdemod(r2,M);
%   back to bits
dataOut_sc = int2bit(rxSym_sc,k);
dataOut_mrc = int2bit(rxSym_mrc,k);
errors_sc = biterr(dataIn,dataOut_sc')/length(dataIn);
errors_mrc = biterr(dataIn,dataOut_mrc')/length(dataIn);

errors_mrc/length(dataIn)
errors_sc/length(dataIn)


img_Linear = bit2int(dataOut_sc,8);
img_Linear_mrc = bit2int(dataOut_mrc,8);
img_reconstructed = reshape(img_Linear,[N N]);
img_reconstructed_mrc = reshape(img_Linear_mrc,[N N]);

%%  Theoretical BER Calculation
% berTheory = berfading(ebnrdB,'qam',M,4,K);

%%  Results Demonstration
% figure;
subplot(1,2,1);
imshow(uint8(img_reconstructed));
subplot(1,2,2);
imshow(uint8(img_reconstructed_mrc));

% figure;
% semilogy(ebnrdB,bitErrorRate_sc,'*','LineWidth',1.5);
% hold on;
% semilogy(ebnrdB,bitErrorRate_mrc,'*','LineWidth',1.5);
% semilogy(ebnrdB,berTheory);
% hold off;
% grid on;
% legend('SC','MRC');

%%  Helper Functions
function r = rice_fading(Kdb,N,Mi)
K = 10^(Kdb/10);
mu = sqrt(K/(2*(K+1)));
sigma = sqrt(1/(2*(K+1)));
% const = 1/(2*(K+1));
x = randn(1,N);
y = randn(1,N);
% r = sqrt(const*((x+sqrt(2*K)).^2 + y.^2));
r = (sigma*x+mu) + 1i*(sigma*y+mu);
rt = zeros(1,Mi*length(r));
ki = 1;
for i=1:length(r)
    %   Rician Fading channel samples
    rt(ki:i*Mi) = r(i);
    ki = ki+Mi;
end
r = rt;
end

function r = selectionCombining(rxSig, h)
% rxSig: [N x L]
% h:     [N x L]
[N, L] = size(h);
r = zeros(N,1);
for n = 1:N
    [~, idx] = max(abs(h(n,:)).^2);  % choose best branch
    r(n) = rxSig(n, idx) ./ h(n, idx); % equalize the chosen branch
end
end

function r = maximalRatioCombining(rxSig,h)
%   rxSig and h are NxL matrices
%   N: number of symbols
%   L: diversity order
[N,L] = size(rxSig);
%   Assume weights equal to the conjugate
w = conj(h);
%   Calculate the norm per symbol
norm_h = zeros(1,N);
for n=1:N
    norm_h(n) = 0;
    for l=1:L
        norm_h(n) = norm_h(n) + abs(h(n,l)).^2;
    end
    norm_h(n) = 1/sqrt(norm_h(n));
end
%   time to use the weight the output
for 
end